---
name: senior-code-standards
description: Enforces senior-level code quality standards. Code must impress other seniors, use advanced patterns and optimizations, include Spanish plans with explicit user tasks, have Spanish comments when needed, and comply with SonarLint/ESLint without tricks or suppressions. Use this skill for ALL code generation to ensure professional, clean, optimized implementations.
---

# Senior Code Standards

This skill defines the non-negotiable quality standards for ALL code generation.
Every piece of code must meet senior-level expectations: clean, optimized,
impressive, and maintainable.

## Core Philosophy

**"If a senior developer reviews my code, they should say: 'Wow, this developer
knows their stuff. How did they do that?'"**

Code is not just functional‚Äîit's a craft. We write code that:

- Impresses experienced developers
- Uses advanced patterns and optimizations
- Solves problems elegantly
- Maintains absolute cleanliness (no linter tricks)
- Communicates clearly in Spanish when needed

## The 4 Non-Negotiable Rules

### Rule 1: Senior-Level Syntax & Style

**Standard:** Code must demonstrate mastery, not just competence.

**What this means:**

- Use advanced language features and patterns
- Optimize for performance and readability
- Employ "perradas" (clever tricks) that senior devs recognize
- Avoid code smells and amateur patterns
- Write code that teaches others something new

**Examples by language:**

#### Python - Senior Level

```python
# ‚ùå Amateur (works but ugly)
def get_active_users(users):
    result = []
    for user in users:
        if user['active'] == True:
            result.append(user['name'])
    return result

# ‚úÖ Senior (clean, Pythonic)
def get_active_users(users: list[dict]) -> list[str]:
    return [user['name'] for user in users if user.get('active')]

# üî• 10x Engineer (with type safety and functional approach)
from typing import TypedDict

class User(TypedDict):
    name: str
    active: bool

def get_active_users(users: list[User]) -> list[str]:
    return [user['name'] for user in filter(lambda u: u['active'], users)]
```

#### JavaScript/TypeScript - Senior Level

```javascript
// ‚ùå Amateur
function getUserNames(users) {
  let names = [];
  for (let i = 0; i < users.length; i++) {
    if (users[i].active) {
      names.push(users[i].name);
    }
  }
  return names;
}

// ‚úÖ Senior
const getActiveUserNames = (users) => 
  users.filter(u => u.active).map(u => u.name);

// üî• 10x Engineer (with TypeScript and modern patterns)
interface User {
  name: string;
  active: boolean;
}

const getActiveUserNames = (users: User[]): string[] =>
  users.filter(({ active }) => active).map(({ name }) => name);
```

#### FastAPI - Senior Level

```python
# ‚ùå Amateur
@app.post("/users")
def create_user(name: str, email: str):
    user = {"name": name, "email": email}
    db.insert(user)
    return user

# ‚úÖ Senior
from pydantic import BaseModel, EmailStr

class UserCreate(BaseModel):
    name: str
    email: EmailStr

@app.post("/users", response_model=User, status_code=201)
async def create_user(user: UserCreate, db: Database = Depends(get_db)):
    created_user = await db.users.insert_one(user.model_dump())
    return await db.users.find_one({"_id": created_user.inserted_id})

# üî• 10x Engineer (with proper error handling and transactions)
from fastapi import HTTPException, status

@app.post("/users", response_model=User, status_code=status.HTTP_201_CREATED)
async def create_user(
    user: UserCreate,
    db: Database = Depends(get_db),
    background_tasks: BackgroundTasks = BackgroundTasks()
) -> User:
    if await db.users.find_one({"email": user.email}):
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="User with this email already exists"
        )
    
    async with await db.start_session() as session:
        async with session.start_transaction():
            created_user = await db.users.insert_one(
                user.model_dump(),
                session=session
            )
            background_tasks.add_task(send_welcome_email, user.email)
            return await db.users.find_one(
                {"_id": created_user.inserted_id},
                session=session
            )
```

### Rule 2: Spanish Plans with Explicit User Tasks

**Standard:** Implementation plans must be in Spanish and clearly mark what the
user must do manually.

**Format for plans:**

````markdown
## üìã Plan de Implementaci√≥n

### Fase 1: Configuraci√≥n Inicial

1. Instalar dependencias
   ```bash
   pip install fastapi stripe pydantic
   ```
````

2. üîë **ESTA TAREA ES TUYA:** Agregar variables de entorno
   ```env
   STRIPE_SECRET_KEY=tu_clave_aqui
   STRIPE_WEBHOOK_SECRET=tu_webhook_secret_aqui
   DATABASE_URL=tu_conexion_db
   ```

3. Crear estructura de carpetas
   ```
   app/
   ‚îú‚îÄ‚îÄ api/
   ‚îú‚îÄ‚îÄ models/
   ‚îî‚îÄ‚îÄ services/
   ```

### Fase 2: Implementaci√≥n Core

1. Crear modelo de datos (yo implemento)
2. Crear servicio de pagos (yo implemento)
3. üîë **ESTA TAREA ES TUYA:** Configurar webhook en Stripe Dashboard
   - URL: https://tu-dominio.com/webhooks/stripe
   - Eventos: payment_intent.succeeded, payment_intent.failed

### Fase 3: Testing

1. Crear tests unitarios (yo implemento)
2. üîë **ESTA TAREA ES TUYA:** Probar en modo test de Stripe con las tarjetas de
   prueba

### Fase 4: Deploy

1. üîë **ESTA TAREA ES TUYA:** Configurar variables en producci√≥n
2. üîë **ESTA TAREA ES TUYA:** Hacer primer deploy
3. Verificar logs (yo te muestro qu√© buscar)

````
**Key principles:**
- Always in Spanish
- Use üîë emoji to mark user tasks
- Be explicit about what's automated vs manual
- Provide context for why something needs manual intervention
- Group related tasks logically

### Rule 3: Spanish Comments (When Necessary)

**Standard:** Code should be self-explanatory, but when comments are needed, they must be in Spanish.

**Guidelines:**
- Prefer expressive variable/function names over comments
- Use comments for complex business logic
- Document "why", not "what"
- All comments in Spanish

```python
# ‚ùå Avoid (obvious comment)
# Calculate the total
total = sum(prices)

# ‚úÖ Good (self-documenting)
total_price = sum(item_prices)

# ‚úÖ Good (explains business logic in Spanish)
def calculate_discount(base_price: float, user_tier: str) -> float:
    # Los usuarios premium obtienen 20% de descuento,
    # pero el descuento m√°ximo es $100 seg√∫n pol√≠tica comercial
    discount_percentage = 0.20 if user_tier == "premium" else 0.10
    max_discount = 100.00
    
    calculated_discount = base_price * discount_percentage
    return min(calculated_discount, max_discount)

# üî• 10x Engineer (complex algorithm explanation in Spanish)
def optimize_route(locations: list[Location]) -> list[Location]:
    """
    Implementa el algoritmo de optimizaci√≥n de rutas usando 
    programaci√≥n din√°mica con memoizaci√≥n.
    
    Complejidad: O(n¬≤) en lugar de O(n!) del enfoque naive.
    
    Args:
        locations: Lista de ubicaciones a visitar
        
    Returns:
        Lista ordenada √≥ptimamente para minimizar distancia total
        
    Nota: Este algoritmo es una variante del TSP (Traveling Salesman Problem)
    optimizado para casos donde n < 50. Para casos m√°s grandes, considerar
    usar heur√≠sticas como el algoritmo gen√©tico.
    """
    # Implementaci√≥n...
````

### Rule 4: SonarLint/ESLint Compliance (No Tricks)

**Standard:** Code must be genuinely clean, not artificially silenced.

**What this means:**

- ‚ùå NEVER use `// eslint-disable-next-line`
- ‚ùå NEVER use `# type: ignore`
- ‚ùå NEVER use `# noqa`
- ‚úÖ Fix the actual problem
- ‚úÖ If unavoidable, explain why in Spanish and use the most specific
  suppression

**Examples:**

```python
# ‚ùå NEVER DO THIS
def risky_function(data):
    return eval(data)  # noqa: S307

# ‚úÖ Fix the actual problem
import ast

def safe_function(data: str) -> dict:
    try:
        return ast.literal_eval(data)
    except (ValueError, SyntaxError) as e:
        raise ValueError(f"Invalid data format: {e}")

# ‚ö†Ô∏è If truly unavoidable (rare), be specific and explain in Spanish
def legacy_integration(data: str) -> Any:
    # Este c√≥digo interact√∫a con un sistema legacy que requiere eval.
    # TODO: Migrar a API REST cuando el sistema legacy sea reemplazado (Q2 2024)
    return eval(data)  # nosec: Validated input from trusted source only
```

```typescript
// ‚ùå NEVER DO THIS
const handleClick = (e: any) => { // eslint-disable-line
    console.log(e);
};

// ‚úÖ Fix with proper types
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
    console.log(e);
};

// ‚ö†Ô∏è If truly unavoidable (very rare)
// Raz√≥n espec√≠fica en espa√±ol de por qu√© este any es necesario:
// La librer√≠a externa no exporta tipos y no tiene @types disponible
type LegacyLibraryEvent = any; // TODO: Crear PR con tipos para la librer√≠a

const handleLegacyEvent = (e: LegacyLibraryEvent) => {
    console.log(e);
};
```

## Advanced Patterns & "Perradas" (Evolving Section)

This section grows over time as you learn new techniques.

### Python Advanced Patterns

#### Context Managers for Clean Resource Handling

```python
from contextlib import asynccontextmanager

@asynccontextmanager
async def database_transaction(db: Database):
    session = await db.start_session()
    async with session.start_transaction():
        try:
            yield session
            await session.commit_transaction()
        except Exception:
            await session.abort_transaction()
            raise
        finally:
            await session.end_session()

# Usage
async with database_transaction(db) as session:
    await db.users.insert_one(user_data, session=session)
```

#### Decorator Patterns for Cross-Cutting Concerns

```python
from functools import wraps
from time import time

def timing_decorator(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start = time()
        result = await func(*args, **kwargs)
        duration = time() - start
        print(f"{func.__name__} tom√≥ {duration:.2f}s")
        return result
    return wrapper

@timing_decorator
async def expensive_operation():
    # Implementation
    pass
```

#### Type-Safe Dependency Injection

```python
from typing import Protocol

class UserRepository(Protocol):
    async def get_user(self, user_id: int) -> User: ...
    async def save_user(self, user: User) -> None: ...

class UserService:
    def __init__(self, repo: UserRepository):
        self.repo = repo
    
    async def update_user(self, user_id: int, data: dict) -> User:
        user = await self.repo.get_user(user_id)
        user.update(data)
        await self.repo.save_user(user)
        return user
```

### JavaScript/TypeScript Advanced Patterns

#### Discriminated Unions for Type Safety

```typescript
type Result<T, E = Error> =
    | { success: true; data: T }
    | { success: false; error: E };

async function fetchUser(id: string): Promise<Result<User>> {
    try {
        const user = await api.getUser(id);
        return { success: true, data: user };
    } catch (error) {
        return { success: false, error: error as Error };
    }
}

// Type-safe usage
const result = await fetchUser("123");
if (result.success) {
    console.log(result.data.name); // TypeScript knows data exists
} else {
    console.error(result.error.message); // TypeScript knows error exists
}
```

#### Advanced React Patterns

```typescript
// Custom hook con cleanup autom√°tico
function useDebounce<T>(value: T, delay: number): T {
    const [debouncedValue, setDebouncedValue] = useState(value);

    useEffect(() => {
        const handler = setTimeout(() => setDebouncedValue(value), delay);
        return () => clearTimeout(handler);
    }, [value, delay]);

    return debouncedValue;
}

// Compound components pattern
const Accordion = ({ children }: { children: React.ReactNode }) => {
    const [openIndex, setOpenIndex] = useState<number | null>(null);

    return (
        <AccordionContext.Provider value={{ openIndex, setOpenIndex }}>
            {children}
        </AccordionContext.Provider>
    );
};

Accordion.Item = AccordionItem;
Accordion.Header = AccordionHeader;
Accordion.Panel = AccordionPanel;
```

### FastAPI Advanced Patterns

#### Dependency Injection with Caching

```python
from functools import lru_cache

@lru_cache
def get_settings() -> Settings:
    return Settings()

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    settings: Settings = Depends(get_settings)
) -> User:
    # Validate token and return user
    pass

@app.get("/protected")
async def protected_route(
    current_user: User = Depends(get_current_user)
):
    return {"user": current_user.email}
```

#### Advanced Validation with Pydantic

```python
from pydantic import BaseModel, validator, root_validator

class BookingCreate(BaseModel):
    service_id: int
    date: datetime
    duration_hours: int
    
    @validator('date')
    def date_must_be_future(cls, v):
        if v < datetime.now():
            raise ValueError('La fecha debe estar en el futuro')
        return v
    
    @root_validator
    def validate_business_hours(cls, values):
        date = values.get('date')
        if date and date.hour < 8 or date.hour > 18:
            raise ValueError('Las reservas deben ser entre 8am y 6pm')
        return values
```

## Code Review Checklist

Before considering code "done", verify:

### Functionality

- [ ] Code works as expected
- [ ] Edge cases handled
- [ ] Error cases handled gracefully

### Senior-Level Quality

- [ ] Uses advanced patterns where appropriate
- [ ] Optimized for performance
- [ ] Would impress another senior developer
- [ ] No obvious code smells

### Communication

- [ ] Plan is in Spanish
- [ ] User tasks clearly marked with üîë
- [ ] Comments (if any) are in Spanish
- [ ] Comments explain "why", not "what"

### Cleanliness

- [ ] No linter warnings or errors
- [ ] No suppression tricks used
- [ ] If suppression necessary, properly justified in Spanish
- [ ] Code is self-documenting

### Type Safety & Best Practices

- [ ] Proper type hints (Python) or TypeScript types
- [ ] No `any` types unless justified
- [ ] Proper error handling
- [ ] Security best practices followed

## Evolution Guidelines

This skill evolves as you learn. When you discover a new pattern or technique:

1. **Document it** in the appropriate section
2. **Provide examples** of the pattern
3. **Explain when to use it** (and when not to)
4. **Show the evolution**: Amateur ‚Üí Senior ‚Üí 10x

### Template for New Patterns

````markdown
#### [Pattern Name]

**Cu√°ndo usarlo:** [Describe the use case]

**Por qu√© es mejor:** [Explain the advantage]

**Ejemplo:**

```[language]
// Show the pattern with clear, working code
```
````

**Advertencias:** [Any gotchas or limitations]

```
## Your Voice as a Developer

This skill represents your coding identity. It says:
- "I care about craft, not just functionality"
- "I learn advanced techniques and apply them"
- "I communicate clearly in my language"
- "I never cut corners on code quality"

Every line of code generated must uphold these values.

---

**Recuerda:** El c√≥digo no solo funciona‚Äîimpresiona. Cada pieza de c√≥digo es una oportunidad para demostrar maestr√≠a.
```
